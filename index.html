<!DOCTYPE html>

<html lang="en">
	<head>
		<title>Unscannable</title>
		<!--
		Attribution
		eleVR webvr boilerplate: https://github.com/hawksley
		-->
	</head>

	<body>
	</body>


	<script src="js/three.min.js"></script>
	<script src="js/VRControls.js"></script>
	<script src="js/VREffect.js"></script>
	<script src="lib/gl-matrix.js"></script>
	<script src="js/VRCursor.js"></script>
	<script src="loaders/OBJloader.js"></script>
	<script src="loaders/MTLLoader.js"></script>
	<script src="loaders/OBJMTLLoader.js"></script>
	<!-- // <script src="lib/tween.js"></script> -->
	<script src="js/PhoneVR.js"></script>

	<script>

		var c = 1/15; //scae factor
		/*
		Setup three.js WebGL renderer
		*/
		var renderer = new THREE.WebGLRenderer( { antialias: true } );
		/*
		Append the canvas element created by the renderer to document body element.
		*/
		document.body.appendChild( renderer.domElement );
		/*
		Create a three.js scene
		*/
		var scene = new THREE.Scene();
		/*
		Create a three.js camera
		*/
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.001, 10000 );

		/*
		Apply VR headset positional data to camera.
		*/
		var controls = new THREE.VRControls( camera, undefined, 4 );

		/*
		Apply VR stereo rendering to renderer
		*/
		var effect = new THREE.VREffect( renderer );
		effect.setSize( window.innerWidth, window.innerHeight );

		/*
		Light
		*/
		var light = new THREE.AmbientLight( 0x404040 );
		scene.add( light );

		var directionalLight = new THREE.DirectionalLight( 0x404040, 5 );
		directionalLight.position.set( 0, 10*c, 0 );
		scene.add( directionalLight );

		var light2 = new THREE.PointLight( 0xffffff, 2, 100 );
		light.position.set( 0, 5*c, 0 );
		scene.add( light2 );


		/*
		Floor
		*/
		var floorImage = new THREE.ImageUtils.loadTexture( "images/stone.jpg" );
		floorImage.wrapS = floorImage.wrapT = THREE.RepeatWrapping;
		floorImage.repeat.set( 10, 10 );
		var floorGeometry = new THREE.PlaneBufferGeometry( 150*c, 150*c, 10 );
		var floorMaterial = new THREE.MeshBasicMaterial( {map: floorImage, color: 0x0475a1, side: THREE.DoubleSide} );
		var floor = new THREE.Mesh( floorGeometry, floorMaterial );
		floor.rotation.x = 90 * Math.PI/180;
		floor.position.y = 0;
		scene.add( floor );

		/*
		Grass
		*/
		var grassImage = new THREE.ImageUtils.loadTexture( "images/grass01.png" );
		var grassGeometry = new THREE.PlaneBufferGeometry(2.5*c,2.5*c);
		var grassMaterial = new THREE.MeshBasicMaterial( {map: grassImage, transparent: true, alphaTest: 0.5, color: 0x3d3d3d});


		var nTufts = 5000;
		var grass = new Array(nTufts);
		for(var i = 0; i < nTufts; i++){
			grass[i] = new THREE.Mesh( grassGeometry, grassMaterial );
			grass[i].position.x	= -100+Math.floor(Math.random()*(201))*c;
			grass[i].position.z	= -100+Math.floor(Math.random()*(201))*c;
			grass[i].position.y = -4.5*c;
			grass[i].rotation.y = (360+Math.floor(Math.random()*(361))) * Math.PI/180;
			scene.add(grass[i]);
		}

		/*
		Charaters
		*/
		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) {
		};

		var blueYellowFloor = new THREE.Object3D();
		// var apricot = new THREE.Object3D();
		var objmtlLoader = new THREE.OBJMTLLoader();

		objmtlLoader.load( 'objs/blueyellowfloor/blueyellowfloor.obj', 'objs/blueyellowfloor/blueyellowfloor.mtl', function ( object ) {
			object.position.z = 0;
			object.position.y = 1;
			object.rotation.x = 140 * Math.PI/180;
			blueYellowFloor = object;
			scene.add( blueYellowFloor );
		}, onProgress, onError );

		// objmtlLoader.load( 'objs/apricot2.obj', 'objs/apricot2.mtl', function ( object ) {
		// 	object.position.z = -10;
		// 	apricot = object;
		// 	scene.add( apricot );
		// }, onProgress, onError );


		// /*
		// Create Cursor
		// */
		// var cursor = new VRCursor();
		// cursor.ready.then(function() {
	 //    	scene.add(cursor.layout);
	 //    	cursor.init(renderer.domElement, camera, scene, selectable);
	 //    	cursor.enable();
	 //    });

		/*
		Request animation frame loop function
		*/
		var t = 1;
		var prevSelected = null;
		function animate() {
			// if (cursor.enabled) {
   //      		cursor.updatePosition();

   //      		if ( cursor.objectMouseOver !== null && prevSelected !== cursor.objectMouseOver) {
   //      			cursor.objectMouseOver.material.color.set(0xffffff);
   //      		}

   //      		if (prevSelected !== null && prevSelected !== cursor.objectMouseOver) {
   //      			prevSelected.material.color.set(0x636363);
   //      		}

   //      		prevSelected = cursor.objectMouseOver;
   //      	}


        	/*
			Character animation
			*/

			t += .03;
			//Bounce
			// apricot.position.y = (Math.sin(t))/2;
			// blueYellowFloor.position.y = ((Math.sin(4 * t) * 1.5)) + 10;

			// //Walk
			// blueYellowFloor.position.x = c*(Math.sin(t*.2)*-25) + (Math.sin(t)*.2) + (Math.sin(t)*.3);
			// blueYellowFloor.position.z = c*(Math.sin(t*.3) * 35) + (Math.sin(t)*.4);
			// blueYellowFloor.lookAt(apricot.position);


			/*
			Update VR headset position and apply to camera.
			*/
			controls.update();


			/*
			Render the scene through the VREffect.
			*/
			// scene.simulate();
			effect.render( scene, camera );
			requestAnimationFrame( animate );

		}

		/*
		Kick off animation loop
		*/
		animate();



		/*
		Listen for double click event to enter full-screen VR mode
		*/
		document.body.addEventListener( 'dblclick', function() {
			effect.setFullScreen( true );
		});

		/*
		Listen for keyboard event and zero positional sensor on appropriate keypress.
		*/
		var vrMode = false;
		function onkey(event) {
	    event.preventDefault();
             if (event.keyCode == 90) { // z
	    	controls.zeroSensor(); //zero rotation
	    } else if (event.keyCode == 70) { //f
	    	effect.setFullScreen(true) //fullscreen
	  	} else if (event.keyCode == 86 || event.keyCode == 13 || event.keyCode == 32 ) { // v or 'enter' or 'space' for VR mode
		    vrMode = !vrMode;
		    effect.setVRMode(vrMode);
			}

	  };

	  window.addEventListener("keydown", onkey, true);


		/*
		Handle window resizes
		*/
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize( window.innerWidth, window.innerHeight );
		}

		window.addEventListener( 'resize', onWindowResize, false );

	</script>
</html>
